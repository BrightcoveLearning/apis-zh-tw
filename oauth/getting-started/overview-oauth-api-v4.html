---
title: '概述：OAuth API'
description: ' OAuth2 的 Brightcove 實現允許您獲取各種 Brightcove API 的訪問令牌。'
parent: Getting Started 
grandparent: OAuth API
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>
    <section class="bcls-section">
    <h2 id="Overview">概述</h2>
    
    <p>Brightcove的實現包括兩個部分：</p>
    
    <ul>
      <li>
      <p>OAuth API - 提供對所有可用 OAuth 功能的訪問</p>
      </li>
      <li>
      <p>OAuth 憑據 UI - 可通過 Studio 中的帳戶設置界面訪問，該 UI 提供了一種簡單的方法來註冊將使用 Brightcove API 並為其生成客戶端 ID 和客戶端密鑰的應用程序。看<a href="/general/managing-api-authentication-credentials.html">管理 API 身份驗證憑據</a>有關使用 OAuth UI 的說明。</p>
      </li>
    </ul>
    
    <p>另請參閱<a href="/oauth/references/reference.html">API參考</a>。</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Glossary_of_terms">專業術語</h2>
    
    <dl>
      <dt>OAuth</dt>
      <dd>
      <p>開放的授權標準。OAuth 代表資源所有者為客戶端應用程序提供' 對服務器資源的安全委託訪問權限。OAuth本質上允許授權服務器在資源所有者的批准下將訪問令牌發布給第三方客戶端。客戶端然後使用訪問令牌訪問由資源服務器託管的受保護資源</p>
      </dd>
      <dt>範圍</dt>
      <dd>
      <p>描述一組資源（可通過API訪問）以及對這些資源的某些操作（例如“讀取"和“寫入"）的數據對象。訪問令牌的範圍限制了您可以通過提供該令牌來執行的操作。</p>
      </dd>
      <dt>客戶</dt>
      <dd>
      <p>最終用戶用於通過Brightcove API訪問資源的應用。</p>
      </dd>
      <dt>客戶編號</dt>
      <dd>
      <p>OAuth服務生成的客戶端的唯一標識符。</p>
      </dd>
      <dt>客戶機密</dt>
      <dd>
      <p>與客戶端ID一起使用的一串比特，用作認證客戶端的密碼。</p>
      </dd>
      <dt>訪問令牌</dt>
      <dd>
      <p>字符串，提供對API的臨時訪問。OToken服務會根據請求為客戶端返回訪問令牌。</p>
      </dd>
      <dt>流</dt>
      <dd>
      <p>導致成功訪問受 OAuth 保護的資源的操作序列。</p>
      </dd>
    </dl>
    </section>
    
    <section class="bcls-section">
    <h2 id="Base_URL">基本網址</h2>
    
    <p>OAuth API 的基本 URL 是：</p>
    
    <pre class="line-numbers">
    <code class="language-http" translate="No">https://oauth.brightcove.com/v4
    </code>
    </pre>
    </section>
    
    <section class="bcls-section">
    <h2 id="Client_credential_flow">客戶憑證流</h2>
    
    <p>在客戶端憑據流程中，您的應用將發出訪問令牌請求，並將您的客戶端ID和客戶端機密與請求一起傳遞給OAuth服務。當前，這是Brightcove客戶唯一支持的流程。</p>
    
    <aside class="bcls-aside bcls-aside--warning">客戶端 ID 和客戶端密碼可用於完全訪問請求的服務。不需要其他身份驗證。因此，客戶端 id 和 secret 應該<strong>絕不</strong>在網頁或其他客戶端中公開。必須從服務器端應用安全地請求訪問令牌。</aside>
    
    <p>客戶端憑據流的確切工作方式將取決於方案。</p>
    
    <h3>組織應用</h3>
    
    <p>在這種情況下，您有一個應用程序需要與一個或多個Brightcove API進行交互，僅適用於屬於您組織的一個或多個帳戶。該應用程序不綁定到任何特定用戶。在這種情況下，工作流程如下所示：</p>
    
    <figure class="bcls-figure"><img class="bcls-image" alt="Client credential workflow for organizational app" src="/assets/images/oauth/getting-started/client-credentials-workflow.png" />
    <figcaption class="bcls-caption--image">組織應用程序的客戶端憑據工作流</figcaption>
    </figure>
    
    <p>要實現此場景，您將執行以下操作：</p>
    
    <ol>
      <li>
      <p>使用 OAuth UI 或 OAuth 服務，為您的應用程序獲取客戶端 ID 和密碼 - UI 允許您獲取單個或多個帳戶的客戶端 ID 和密碼。這是一次性操作。</p>
      </li>
      <li>
      <p>向您的服務器端應用添加邏輯，以向OAuth API發出訪問令牌的請求。實施將取決於您的應用程序的語言（建議您使用現有的語言<a href="#Client_samples_and_libraries">OAuth2庫</a>如果可能的話，請選擇您的語言），但您撥打的電話將是POST請求，以：</p>
    
      <pre class="line-numbers">
    <code class="language-http" translate="No">https://oauth.brightcove.com/v4/access_token
    </code>
    </pre>
    
      <p>這<code translate="No">client_id</code>和<code translate="No">client_secret</code>被作為<code translate="No">username:password</code>在基本授權標頭中：</p>
    
      <pre class="line-numbers">
    <code translate="No">Authorization: Basic {client_id}:{client_secret}
    </code>
    </pre>
    
      <p>整個<code translate="No">{client_id}:{client_secret}</code>字符串必須是 Base64 編碼的（例如，在 Node.js 中，您可以使用<code translate="No">Buffer.toString("base64")</code>方法）。CURL自動執行BASE64編碼，因此您只需將憑據傳遞為<code translate="No">user {client_id}:{client_secret}</code>。您還需要包括一個<code translate="No">Content-Type: application/x-www-form-urlencoded</code>標題。</p>
    
      <p>請求正文將包含鍵/值對<code translate="No">grant_type=client_credentials</code> .請注意，由於<code translate="No">Content-type</code>是<code translate="No">x-www-form-urlencoded</code>，您也可以將其作為參數附加到請求網址中：</p>
    
      <pre>
    <code class="language-http" translate="No">https://oauth.brightcove.com/v4/access_token?grant_type=client_credentials</code></pre>
    
      <p>以下是一個非常基本的Node.js應用，它將獲得<code translate="No">access_token</code>給予有效<code translate="No">client_id</code>和<code translate="No">client_secret</code>。</p>
    
      <pre class="line-numbers">
    <code class="language-javascript" translate="No">/*
    * Simple node app to get an access_token for a Brightcove API
    * You will need to substitute valid client_id and client_secret values
    * for {your_client_id} and {your_client_secret}
    */
    var request = require('request');
    var client_id = "{your_client_id}";
    var client_secret = "{your_client_secret}";
    var auth_string = new Buffer(client_id + ":" + client_secret).toString('base64');
    console.log(auth_string);
    request({
    method: 'POST',
    url: 'https://oauth.brightcove.com/v4/access_token',
    headers: {
    'Authorization': 'Basic ' + auth_string,
    'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: 'grant_type=client_credentials'
    }, function (error, response, body) {
    console.log('Status: ', response.statusCode);
    console.log('Headers: ', JSON.stringify(response.headers));
    console.log('Response: ', body);
    console.log('Error: ', error);
    });
    </code>
    </pre>
      </li>
      <li>
      <p>響應正文將如下所示：</p>
    
      <pre class="line-numbers">
    <code class="language-json" translate="No">{
    "access_token": "ACikM-7Mu04V5s7YBlKgTiPu4ZO3AsTBlWt-73l5kXRN4IeRuIVlJHZkq_lFQdZBYfzT9B_nHNgcmNFdalxSiNdqOBaaV7wQCCnRCua_efHNCg9d_yLbezcjxr3AGcBKy9a8_t-uTMTA46T24LKMOBGBNJFkyATSZI4JuxU71VIyGF9hDisbKHmKC5G5HdQ0nJgyCD1w1zkKrB1CpFb5iiBuA_XOzehF-Xf5DBYnSkDhzzByuFwTv9dU9d7W6V2OuiKiTzCzY3st01qJTk6-an6GcAOD4N5pdN8prvvMDQhz_HunJIamvVGqBz7o3Ltw8CFFJMXKQdeOF8LX31BDnOvMBEz-xvuWErurvrA0r6x5eZH8SuZqeri4ryZAsaitHiJjz9gp533o",
    "token_type": "Bearer",
    "expires_in": 300
    }
    </code>
    </pre>
    
      <p>您將需要捕獲<code translate="No">access_token</code> .除非您的電話是間歇性的，在這種情況下您將請求一個新的<code translate="No">access_token</code>對於每個 API 調用，您還需要捕獲<code translate="No">expires_in</code>值，以便您可以將其用於以後的請求以檢查您的令牌是否仍然有效 - 如果不是，您將需要請求一個新的。這<code translate="No">expires_in</code>值以秒為單位。</p>
      </li>
      <li>
      <p>一旦有了<code translate="No">access_token</code>，您可以調用Brightcove API，包括<code translate="No">Authorization</code>標頭形式：</p>
    
      <pre class="line-numbers">
    <code class="language-http" translate="No">Authorization: Bearer {access_token}
    </code>
    </pre>
      </li>
    </ol>
    
    <p>看<a href="/oauth/guides/getting-access-tokens.html">獲取訪問令牌</a>有關更多詳細信息和代碼示例。</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="General_Authorization">一般授權</h2>
    
    <p>此方案主要適用於 Brightcove 合作夥伴，他們將創建可供各種組織中的 Brightcove 用戶使用的應用程序。此場景的工作流程如下所示：</p>
    
    <figure class="bcls-figure"><img class="bcls-image" alt="Client Credential Workflow for Multi-Organization App" src="/assets/images/oauth/getting-started/authorization-workflow.png" />
    <figcaption class="bcls-caption--image">多組織應用程序的客戶端憑據工作流</figcaption>
    </figure>
    
    <p>實現這個場景而不是第一個場景的唯一區別是用戶必須從 OAuth UI 獲取您的應用程序的客戶端 ID 和機密，並通過表單將這些提供給您。然後，您將這些傳遞給您的應用程序，以提交請求<code translate="No">access_token</code> .除此之外，一切都將是相同的。</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Get_Client_Credentials">獲取客戶憑證</h2>
    
    <p>獲取客戶端憑據的最簡單方法（<code translate="No">client_id</code>和<code translate="No">client_secret</code> ) 是使用<a href="/general/managing-api-authentication-credentials.html">OAuth 用戶界面</a> .但是，如果您希望直接從OAuth服務獲取它們，則可以通過發出POST請求來實現。<code class="language-http" translate="No">https://oauth.brightcove.com/v4/client_credentials</code>，傳遞以下標頭：</p>
    
    <ul>
      <li><code translate="No">Content-Type: application/json</code></li>
      <li><code translate="No">Authorization: BC_TOKEN <em>your BC_TOKEN</em></code></li>
    </ul>
    
    <p>您還需要發送一個 JSON 對像作為有效負載：</p>
    
    <pre class="line-numbers">
    <code class="language-json" translate="No">{
      "type": "credential",
      "maximum_scope": [
        {
          "identity": {
            <span class="video-cloud-only">"type": "video-cloud-account",</span>
            <span class="player-only">"type": "perform-account",</span>
            "account-id": <em>account_id1</em>
          },
          "operations": [
            "video-cloud/player/all"
          ]
        },
        {
          "identity": {
          <span class="video-cloud-only">"type": "video-cloud-account",</span>
          <span class="player-only">"type": "perform-account",</span>
          "account-id": <em>account_id2</em>
        },
        "operations": [
          "video-cloud/player/all"
        ]
        }
      ],
      "name": "AnalyticsClient",
      "description": "My analytics app"
    }
    </code>
    </pre>
    </section>
    
    <section class="bcls-section">
    <h2 id="Operations">運作方式</h2>
    
    <p>這裡唯一會有所不同的是<code translate="No">operations</code>值，這取決於您要訪問的 API，以及您是否要訪問讀取、寫入或兩者兼有的操作。看<a href="/oauth/guides/api-operations-client-credentials-requests.html">客戶端憑據請求的 API 操作</a>獲取當前支持的所有操作的列表。</p>
    
    <p>有關使用curl或Postman獲取客戶端憑據的詳細指南，請參閱：</p>
    
    <ul>
      <li><a href="/oauth/guides/oauth-create-client-credentials-using-curl.html">使用CURL獲取客戶端憑據</a></li>
      <li><a href="/oauth/guides/oauth-create-client-credentials-using-postman.html">使用郵遞員獲取客戶憑證</a></li>
    </ul>
    </section>
    
    <section class="bcls-section">
    <h2 id="Working_with_OAuth">使用 OAuth</h2>
    
    <p>要構建邏輯來處理為您的 API 請求獲取訪問令牌，有兩種通用方法可以繼續。</p>
    
    <p>如果要構建單個服務器端應用程序，則將邏輯構建到應用程序中是有意義的。操作順序如下所示：</p>
    
    <figure class="bcls-figure"><img class="bcls-image" alt="Single App Sequence" src="/assets/images/oauth/getting-started/SingleApp.svg" />
    <figcaption class="bcls-caption--image">單個應用程序序列</figcaption>
    </figure>
    
    <p>相反，如果您將構建需要調用Brightcove API的多個應用程序，或者如果您創建客戶端Web應用程序，則將代碼合併起來以將訪問令牌合併到單個代理中將更有意義。在這種情況下，操作序列將如下所示：</p>
    
    <figure class="bcls-figure"><img class="bcls-image" alt="Proxy Sequence" src="/assets/images/oauth/getting-started/Proxy.svg" />
    <figcaption class="bcls-caption--image">代理順序</figcaption>
    </figure>
    
    <p>見<a href="/oauth/getting-started/quick-start-oauth.html">快速開始</a>有關創建簡單代理的詳細說明。</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Client_samples_and_libraries">客戶樣本和庫</h2>
    
    <p>我們創造了<a href="https://github.com/BrightcoveLearning/oauth-client-examples">示例客戶端實現</a>以多種語言為您提供實現模型。</p>
    
    <p>還有適用於多種語言的 OAuth2 庫，我們通常鼓勵您盡可能使用這些庫，而不是構建與 OAuth API 的交互。以下是可用庫的部分列表。有關更廣泛的列表，請參見<a href="http://oauth.net/2/">http://oauth.net/2/</a></p>
    
    <dl><!-- <dt>Node JS/JavaScript</dt>
    <dd>
    <ul>
    <li><a href="https://github.com/ciaranj/node-oauth">node-oauth</a></li>
    <li><a href="http://github.com/andreassolberg/jso">Javascript</a></li>
    </ul>
    </dd> -->
      <dt>Python</dt>
      <dd>
      <ul>
        <li><a href="http://github.com/demianbrecht/sanction">制裁</a></li>
        <li><a href="http://github.com/litl/rauth">認證</a></li>
        <li><a href="https://pypi.python.org/pypi/oauth2/1.5.211">python-oauth2</a></li>
      </ul>
      </dd>
      <dt>的PHP</dt>
      <dd>
      <ul>
        <li><a href="http://www.phpclasses.org/package/7700-PHP-Authorize-and-access-APIs-using-OAuth.html">的PHP</a></li>
        <li><a href="https://github.com/fkooman/php-oauth-client">PHP OAuth 2.0客戶端</a></li>
        <li><a href="https://github.com/ivan-novakov/php-openid-connect-client">適用於PHP / Zend Framework 2的OAuth2 / OpenID Connect客戶端庫</a></li>
      </ul>
      </dd>
      <dt>可可</dt>
      <dd><a href="http://github.com/leebyron/cocoa-oauth2">可可</a></dd>
      <dt>的iOS</dt>
      <dd><a href="http://github.com/lukeredpath/LROAuth2Client">iPhone和iPad</a></dd>
      <dt>iOS和Mac MacOS</dt>
      <dd><a href="http://github.com/nxtbgthng/OAuth2Client">iOS和Mac MacOS</a></dd>
      <dt>爪哇</dt>
      <dd>
      <ul>
        <li><a href="http://oltu.apache.org/">阿帕奇·奧爾圖（Apache Oltu）</a></li>
        <li><a href="http://www.springsource.org/spring-social">春季社交</a></li>
        <li><a href="http://static.springsource.org/spring-security/oauth/">OAuth 的 Spring 安全性</a></li>
        <li><a href="http://www.restlet.org/">Restlet框架（草案30）</a></li>
      </ul>
      </dd>
      <dt>紅寶石</dt>
      <dd>
      <ul>
        <li><a href="http://github.com/intridea/oauth2">紅寶石</a></li>
        <li><a href="http://github.com/aflatter/oauth2-ruby">紅寶石</a></li>
      </ul>
      </dd>
      <dt>。網</dt>
      <dd>
      <ul>
        <li><a href="http://www.nuget.org/packages/Microsoft.Owin.Security.OAuth">OWIN中間件</a></li>
        <li><a href="http://www.dotnetopenauth.net/">DotNetOpenAuth</a></li>
        <li><a href="http://www.springframework.net/social/">.NET 的 Spring 社交</a></li>
      </ul>
      </dd>
      <dt>Qt / C ++</dt>
      <dd><a href="https://github.com/pipacs/o2">氧氣2</a></dd>
    </dl>
    </section>
    </article>
 